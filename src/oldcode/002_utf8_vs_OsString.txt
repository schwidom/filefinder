/*
    "basename1" => { 
      if let Sexp::Atom( Atom::S(path)) = &state.stmt[1] { // TODO : error handling
       // eprintln!("{:?}", path);
       // eprintln!("{:?}", state.path.clone());
       // eprintln!("{:?}", state.path.clone().unwrap().file_name());
       // eprintln!("{:?}", state.path.clone().unwrap().file_name().unwrap());
       // *path == state.path.unwrap().file_name().unwrap().to_str().unwrap().to_string()
       // BUG : path ist ein String während der file_name ein OsString ist, d.h. es gibt kaputte
       // Filenamen, die nicht der UTF-8 Spec entsprechen und damit nicht benannt werden können über die Sexp
       // hier wäre ein encoding regexes o.ä. sinnvoll
       // Die Lösung besteht in der Verwendung von OsString.to_string_lossy

       OsString::from( path) == state.path.unwrap().file_name().unwrap() &&
       self.interpret_slice( State::<&[Sexp]>{ stmt : &state.stmt[ 2..].to_vec() , path : state.path })
      } else {
       panic!("error in {}: string expected", atom)
      }
    }, 
*/
